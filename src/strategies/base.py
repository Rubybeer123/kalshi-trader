"""Abstract base class for trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, Optional

from src.candle_aggregator import OHLCV, Tick


class SignalType(str, Enum):
    """Types of trading signals."""
    LONG = "long"
    SHORT = "short"
    EXIT = "exit"


@dataclass(frozen=True)
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        type: Signal type (LONG, SHORT, EXIT)
        market_ticker: Target market
        entry_price: Suggested entry price
        stop_loss: Stop loss level
        take_profit: Take profit level
        confidence: Signal confidence (0.0 to 1.0)
        metadata: Additional strategy-specific data
    """
    type: SignalType
    market_ticker: str
    entry_price: float
    stop_loss: float
    take_profit: float
    confidence: float = field(default=0.5)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate confidence is in valid range."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")
    
    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk/reward ratio."""
        if self.type == SignalType.LONG:
            risk = self.entry_price - self.stop_loss
            reward = self.take_profit - self.entry_price
        elif self.type == SignalType.SHORT:
            risk = self.stop_loss - self.entry_price
            reward = self.entry_price - self.take_profit
        else:  # EXIT
            return 0.0
        
        if risk == 0:
            return 0.0
        
        return reward / risk
    
    @property
    def stop_distance(self) -> float:
        """Calculate distance to stop loss."""
        if self.type == SignalType.LONG:
            return self.entry_price - self.stop_loss
        elif self.type == SignalType.SHORT:
            return self.stop_loss - self.entry_price
        return 0.0
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary."""
        return {
            'type': self.type.value,
            'market_ticker': self.market_ticker,
            'entry_price': self.entry_price,
            'stop_loss': self.stop_loss,
            'take_profit': self.take_profit,
            'confidence': self.confidence,
            'risk_reward_ratio': self.risk_reward_ratio,
            'stop_distance': self.stop_distance,
            'metadata': self.metadata,
        }


class Strategy(ABC):
    """
    Abstract base class for trading strategies.
    
    All strategies must implement:
    - on_candle: Process completed candle
    - on_tick: Process real-time tick
    - get_required_warmup: Number of candles needed before trading
    - name: Strategy identifier
    """
    
    @abstractmethod
    def on_candle(self, market_ticker: str, candle: OHLCV) -> Optional[Signal]:
        """
        Process a completed candle.
        
        Args:
            market_ticker: Market identifier
            candle: Completed OHLCV candle
            
        Returns:
            Signal if strategy triggers, None otherwise
        """
        pass
    
    @abstractmethod
    def on_tick(self, market_ticker: str, tick: Tick) -> Optional[Signal]:
        """
        Process a real-time tick.
        
        Args:
            market_ticker: Market identifier
            tick: Real-time tick data
            
        Returns:
            Signal if strategy triggers, None otherwise
        """
        pass
    
    @abstractmethod
    def get_required_warmup(self) -> int:
        """
        Get number of candles required before strategy can generate signals.
        
        Returns:
            Number of warmup periods needed
        """
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """
        Get strategy name.
        
        Returns:
            Unique strategy identifier
        """
        pass
    
    def can_trade(self, candle_count: int) -> bool:
        """
        Check if strategy has enough data to trade.
        
        Args:
            candle_count: Number of candles available
            
        Returns:
            True if strategy can generate signals
        """
        return candle_count >= self.get_required_warmup()
    
    def __repr__(self) -> str:
        """String representation."""
        return f"{self.__class__.__name__}(name='{self.name}')"


class StrategyError(Exception):
    """Base exception for strategy errors."""
    pass


class InsufficientDataError(StrategyError):
    """Raised when strategy doesn't have enough warmup data."""
    pass
